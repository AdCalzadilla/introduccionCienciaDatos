---
title: "Informe trabajo final Introducción a la Ciencia de Datos. Máster en Ciencia de Datos e Ingeniería de Computadores"
author: "Adrián Calzadilla González"
date: "9 de Enero de 2017"
output: pdf_document
#toc: yes
fig_caption: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
\newpage
\tableofcontents
\listoffigures
\newpage

## Regresión dataset Wizmir

### Objetivo

Este fichero contiene la información del tiempo de la ciudad de *Esmira* (*Izmir*), que es el segundo mayor puerto de Turquía tras Estambul y la tercera ciudad del país en población con 4.168.415 habitantes en 2015. El fichero posee la información del tiempo correspondiente al periodo *01/01/1994* hasta el *31/12/1997*. A partir de estas características el objetivo es predecir la temperatura media.

### Análisis de datos

#### Hipótesisi inicial

La temperatura media se trata a partir de promedios estadísticos cogidos a lo largo del día. Por lo tanto es muy posible que la relación entre la temperatura media, y las temperaturas máximas y mínimas sea importante para realizar un buen modelo.

#### Análisis general

Para analizar el conjunto de datos proporcionado. En primer lugar se lee y exporta el fichero con los datos de *wizmir*, se crean las funciones que se van a utilizar en el proceso así como las estructuras de datos necesarias. Se introducen los nombres de las variables a mano y se comprueba si es un *data.frame*.

```{r}
# Paquetes que vamos a utilizar
require(kknn)

wizmir <- read.csv2("./wizmir/wizmir.dat", header = F, sep = ",", comment.char = "@", dec = ".")
names(wizmir) <- c("Max_temperature", "Min_temperature", "Dewpoint",
                   "Precipitation", "Sea_level_pressure", "Standard_pressure",
                   "Visibility", "Wind_speed", "Max_wind_speed", "Mean_temperature")

# Creamos varias funciones que utilizaremos a lo largo del código

## Función para calcular el porcentaje

percentage <- function(x){
  x * 100
}

## Función para calcular la moda

getMode <- function(v) {
  uniqv <- unique(v)
  uniqv[which.max(tabulate(match(v, uniqv)))]
}

# Función para calcular el error RMSE (Error cuadrático medio)
RMSE <- function(x){
  # Formula
  yprime=predict(x,wizmir)
  sqrt(sum(abs(Mean_temperature-yprime)^2)/length(yprime))
}

# Función para calcular el error al usar knn
knnRMSE <- function(x){
  yprime <- x$fitted.values
  sqrt(sum((Mean_temperature-yprime)^2)/length(yprime)) #RMSE
}

# Estructura de datos para guardar los valores obtenidos de un modelo.
df <- data.frame(
  r.squared = numeric(0),
  porCiento_R = numeric(0),
  adj.r.squared = numeric(0),
  porCientoR2 = numeric(0),
  RMSE = numeric(0))

# Función para crear las filas del data.frame

createRow <- function(x){
  valueList <- c(round(summary(x)$r.squared, digits = 4),
                 percentage(summary(x)$r.squared),
                 round(summary(x)$adj.r.squared, digits = 4),
                 percentage(summary(x)$adj.r.squared),
                 rmse)
}

# Función para poner el nombre a cada fila del data.frame df.

putName <- function(nameRow, df){
  aux <- row.names(df)
  aux[length(aux)] <- nameRow
  row.names(df) <- aux
  df
}
```

Seguidamente, se analiza el *data.frame* y el tipo de variables que contiene:

```{r}
## Características generales de wizmir
attach(wizmir)
is.data.frame(wizmir)
dim(wizmir)
str(wizmir)

### Existen valores "NA"
table(is.na(wizmir))

### Tipos de datos de las variables
is.double(Max_temperature)
is.double(Min_temperature)
is.double(Dewpoint)
is.double(Precipitation)
is.double(Sea_level_pressure)
is.double(Standard_pressure)
is.double(Visibility)
is.double(Wind_speed)
is.double(Max_wind_speed)
is.double(Mean_temperature)
```

Resumen del *data.frame* en el que se nos muestra el valor máximo y mínimo registrado, el primer cuartil, la mediana, el tercer cuartil y la media de cada variable.

```{r}
summary(wizmir)
```

A continuación, se calculan algunas métricas que no salen en *summary*:

```{r}
## Desviación estandar para cada una de las variables
allSd <- apply(wizmir, 2, sd)
## Mediana de cada una de las variables
allMedian <- apply(wizmir, 2, median)
## Rango intercuartílico
allIQR <- apply(wizmir, 2, IQR)
```

Por último, se grafican todas las variables todas con todas. Tal como se muestra en la *Figura \ref{fig:plotWizmir}*.

```{r test, fig.cap="Plot de todas las variables contra todas\\label{fig:plotWizmir}", fig.lp="test"}
# Gráfica de todos con todos
plot(wizmir)
```

### Variables

Conjunto de datos explicado uno a uno.

#### Max_temperature

Esta variable se utiliza para guardar la temperatura máxima obtenida en cada observación. Su unidad es el grado *Farenheit*.

#####  Medidas de centralidad

```{r}
mean(Max_temperature)
median(Max_temperature)
getMode(Max_temperature)
```

##### Medidas de dispersión

```{r}
var(Max_temperature)
sd(Max_temperature)
max(Max_temperature)
min(Max_temperature)
range(Max_temperature)
quantile(Max_temperature)
```

##### Gráfica de Max_temperature respecto a Mean_temperature, la salida.

En la *Figura \ref{fig:plotMaxTemperature}* se puede observar la gráfica de *Max_temperature* respecto a la salida.

```{r, fig.cap="plot Max_temperature respecto a Mean_temperature\\label{fig:plotMaxTemperature}"}
plot(Max_temperature, Mean_temperature)
```

#### Min_temperature

Variable que se utiliza para guardar la temperatura mínima registrada a lo largo del día, se mide en grados *Farenheit*.

#####  Medidas de centralidad

```{r}
mean(Min_temperature)
median(Min_temperature)
getMode(Min_temperature)
```

##### Medidas de dispersión

```{r}
var(Min_temperature)
sd(Min_temperature)
max(Min_temperature)
min(Min_temperature)
range(Min_temperature)
quantile(Min_temperature)
```

##### Gráfica de Min_temperature respecto a Mean_temperature, la salida.

La figura *Figura \ref{fig:plotMinTemperature}* representa *Min_temperature* respecto a la salida.

```{r, fig.cap="plot de Min_temperature con Mean_temperature\\label{fig:plotMinTemperature}"}
plot(Min_temperature, Mean_temperature)
```

#### Dewpoint

El punto de rocío es la temperatura a la que empieza a condensarse el vapor de agua contenido en el aire. La saturación se produce por un aumento de humedad relativa con la misma temperatura, o por un descenso de temperatura con la misma humedad relativa. En este caso su unidad son los grados *Farenheit*.

#####  Medidas de centralidad

```{r}
mean(Dewpoint)
median(Dewpoint)
getMode(Dewpoint)
```

##### Medidas de dispersión

```{r}
var(Dewpoint)
sd(Dewpoint)
max(Dewpoint)
min(Dewpoint)
range(Dewpoint)
quantile(Dewpoint)
```

##### Gráfica de Dewpoint respecto a Mean_temperature, la salida.

En la *Figura \ref{fig:plotDewpoint}* se puede ver la representación gráfica de *Dewpoint* respecto a la salida.

```{r, fig.cap="plot de Dewpoint con Mean_temperature\\label{fig:plotDewpoint}"}
plot(Dewpoint, Mean_temperature)
```

#### Precipitation

Se considera *precipitación* a cualquier producto de la condensación del vapor de agua que cae bajo el efecto de la gravedad. Las principales formas de precipitación incluyen: lluvia, aguanieve, nieve y granizo.

Este fenómeno ocurre cuando una porción de la atmósfera se satura con vapor de agua, de modo que el agua se condensa y cae.

##### Medidas de centralidad

```{r}
mean(Precipitation)
median(Precipitation)
getMode(Precipitation)
```

##### Medidas de dispersión

```{r}
var(Precipitation)
sd(Precipitation)
max(Precipitation)
min(Precipitation)
range(Precipitation)
quantile(Precipitation)
```

##### Gráfica de Precipitation respecto a Mean_temperature, la salida.

```{r, fig.cap="plot de Precipitation con Mean_temperature\\label{fig:plotPrecipitation}"}
plot(Precipitation, Mean_temperature)
```

#### Sea_level_pressure

La presión atmosférica, a cualquier elevación, se reduce a un valor que se aproxima a la presión al nivel del mar. La unidad en la que se mide esta variable es *inHg*.

##### Medidas de centralidad

```{r}
mean(Sea_level_pressure)
median(Sea_level_pressure)
getMode(Sea_level_pressure)
```

##### Medidas de dispersión

````{r}
var(Sea_level_pressure)
sd(Sea_level_pressure)
max(Sea_level_pressure)
min(Sea_level_pressure)
range(Sea_level_pressure)
quantile(Sea_level_pressure)
```

##### Gráfica de Sea_level_pressure respecto a Mean_temperature, la salida.

```{r, fig.cap="plot de Sea_level_pressure con Mean_temperature\\label{fig:plotSeaLevelPressure}"}
plot(Sea_level_pressure, Mean_temperature)
```

#### Standard_pressure

Las condiciones estándar para la presión son mediciones experimentales que se establecen para poder permitir comparaciones entre diferentes conjuntos de datos.

#####  Medidas de centralidad

```{r}
mean(Standard_pressure)
median(Standard_pressure)
getMode(Standard_pressure)
```

##### Medidas de dispersión

```{r}
var(Standard_pressure)
sd(Standard_pressure)
max(Standard_pressure)
min(Standard_pressure)
range(Standard_pressure)
quantile(Standard_pressure)
```

##### Gráfica de Standard_pressure respecto a Mean_temperature, la salida.

La *Figura \ref{fig:plotStandardPressure}* muestra la gráfica entre esta variable y *Mean_temperature*.

```{r, fig.cap="plot de Standard_Pressure con Mean_temperature\\label{fig:plotStandardPressure}"}
plot(Standard_pressure, Mean_temperature)
```

#### Visibility

Para medir esta variable se realiza medidas de la transmisividad luminosa de la atmósfera y tratar de ajustar los valores a los de visibilidad.

##### Medidas de centralidad

```{r}
mean(Visibility)
median(Visibility)
getMode(Visibility)
```

##### Medidas de dispersión

```{r}
var(Visibility)
sd(Visibility)
max(Visibility)
min(Visibility)
range(Visibility)
quantile(Visibility)
```

##### Gráfica de Visibility respecto a Mean_temperature, la salida.

En la *Figura \ref{fig:plotVisibility}* se muestra la gráfica de *Visibility* respecto a la salida.

```{r, fig.cap="plot de Visibility con Mean_temperature\\label{fig:plotVisibility}"}
plot(Visibility, Mean_temperature)
```

#### Wind_speed

Esta variable muestra la velocidad del viento.

##### Medidas de centralidad

```{r}
mean(Wind_speed)
median(Wind_speed)
getMode(Wind_speed)
```

##### Medidas de dispersión

```{r}
var(Wind_speed)
sd(Wind_speed)
max(Wind_speed)
min(Wind_speed)
range(Wind_speed)
quantile(Wind_speed)
```

##### Gráfica de Wind_speed respecto a Mean_temperature, la salida.

La *Figura \ref{fig:plotWindSpeed}* muestra la gráfica de *WindSpeed* contra *Mean_temperature*.

```{r, fig.cap="plot de Wind_speed con Mean_temperature\\label{fig:plotWindSpeed}"}
plot(Wind_speed, Mean_temperature)
```

#### Max_wind_speed

La variable *Max_wind_speed* ofrece la velocidad máxima del viento obtenida a lo largo del día.

##### Medidas de centralidad

```{r}
mean(Max_wind_speed)
median(Max_wind_speed)
getMode(Max_wind_speed)
```

##### Medidas de dispersión

```{r}
var(Max_wind_speed)
sd(Max_wind_speed)
max(Max_wind_speed)
min(Max_wind_speed)
range(Max_wind_speed)
quantile(Max_wind_speed)
```

##### Gráfica de Max_wind_speed respecto a Mean_temperature, la salida.

En la *Figura \ref{fig:plotMaxWindSpeed}* se puede observar la gráfica de *Max_wind_speed* respecto a la salida.

```{r, fig.cap="plot de Max_wind_speed con Mean_temperature\\label{fig:plotMaxWindSpeed}"}
plot(Max_wind_speed, Mean_temperature)
```

### Regresión lineal

#### Ajuste lineal simple

Después de graficar cada una de las variables contra la salida, se toman como variables candidatas para el ajuste lineal simple a *Max_temperature* y *Min_temperature* como favoritas. Además también se calcula la regresión lineal a las variables: *Dewpoint*, *Sea_level_pressure* y *Standard_pressure*.

##### Max_temperature

```{r}
lm1 <- lm(Mean_temperature~Max_temperature, data = wizmir)
summary(lm1)
```

Una vez calculado *lm1* se grafica, tal como se muestra en la *Figura \ref{fig:plotLm1}*.

```{r, fig.cap="plot de lm1 con Mean_temperature\\label{fig:plotLm1}"}
plot(Mean_temperature~Max_temperature, wizmir)
abline(lm1, col="red")
```

```{r}
confint(lm1)
rmse <- RMSE(lm1)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm1)
# Almacenamiento de los valores en el data.frame df
df[1,] <- valueList
df <- putName("lm1", df)
```

##### Min_temperature

```{r}
lm2 <- lm(Mean_temperature~Min_temperature, data = wizmir)
summary(lm2)
```

La *Figura \ref{fig:plotLm2}* muestra la regresión lineal en una gráfica.

```{r, fig.cap="plot de Lm2 con Mean_temperature\\label{fig:plotLm2}"}
plot(Mean_temperature~Min_temperature, wizmir)
abline(lm2, col="red")
```

```{r}
confint(lm2)
rmse <- RMSE(lm2)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm2)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm2",df)
```

##### Dewpoint

```{r}
lm3 <- lm(Mean_temperature~Dewpoint, data = wizmir)
summary(lm3)
```

En la *Figura \ref{fig:plotLm3}* se puede observar la regresión lineal *lm3*.

```{r, fig.cap="plot de Lm3 con Mean_temperature\\label{fig:plotLm3}"}
plot(Mean_temperature~Dewpoint, wizmir)
abline(lm3, col= "red")
```

```{r}
confint(lm3)
rmse <- RMSE(lm3)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm3)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm3",df)
```

##### Sea_level_pressure

```{r}
lm4 <- lm(Mean_temperature~Sea_level_pressure, data = wizmir)
summary(lm4)
```

La *Figura \ref{fig:plotLm4}* muestra el ajuste lineal calculado respecto a la salida.

```{r, fig.cap="plot de Lm4 con Mean_temperature\\label{fig:plotLm4}"}
plot(Mean_temperature~Sea_level_pressure, wizmir)
abline(lm4, col = "red")
```

```{r}
confint(lm4)
rmse <- RMSE(lm4)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm4)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm4",df)
```

##### Standard_pressure

```{r}
lm5 <- lm(Mean_temperature~Standard_pressure, data = wizmir)
summary(lm5)
```

El ajuste lineal realizado entre *Standard_pressure* y *Mean_temperature* se puede observar en la *Figura \ref{fig:plotLm5}*.

```{r, fig.cap="plot de Lm5 con Mean_temperature\\label{fig:plotLm5}"}
plot(Mean_temperature~Standard_pressure, data = wizmir)
abline(lm5, col = "red")
```

```{r}
confint(lm5)
rmse <- RMSE(lm5)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm5)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm5",df)
```

##### Resultados

Para medir la bondad de los ajustes realizados y ver que ajuste lineal es mejor se va a utlizar el *R cuadrado*.

Al finalizar el ajuste lineal simple de las variables seleccionadas, se ha comprobado que tanto *Max_temperature* como *Min_temperature* tienen un valor de *R cuadrado* muy bueno superior al 91%. Las otras variables quedan descartadas debido a que su *R cuadrado* es muy bajo girando en torno al 61% la mejor de ellas, tal como se muestra en la siguiente tabla:

```{r}
df
```

#### Modelo lineal múltiple

Para ver que ajuste lineal múltiple es mejor se va a utlizar el *R2 ajustado* ya que, *R cuadrado* aumenta automáticamente a medida que se agrega nuevas variables independientes a una ecuación de regresión. *R2 ajustado* aumenta sólo cuando se agregan nuevas variables independientes que hacen aumentar el poder explicativo de la ecuación de regresión.

En primer lugar se calcula el modelo lineal para los dos mejores valores de *R cuadrado* conocidos hasta ahora: *Max_temperature* y *Min_temperature*.

##### Max_temperature y Min_temperature

```{r}
## Max_temperature y Min_temperature (Mejor aproximación por separado)

lm6 <- lm(Mean_temperature~Max_temperature+Min_temperature, data = wizmir)
summary(lm6)
rmse <- RMSE(lm6)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm6)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm6",df)
```

##### Modelo con todas las variables

Se prueba un ajuste lineal con todas las variables.

```{r}
lm7 <- lm(Mean_temperature~., data = wizmir)
summary(lm7)
rmse <- RMSE(lm7)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm7)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm7",df)
```

##### Eliminación variables no relevantes

Del ajuste realizado en el paso anterior se quitan aquellas variables que interfieran muy poco en el resultado.

```{r}
lm8 <- lm(Mean_temperature~.-Precipitation-Wind_speed, data = wizmir)
summary(lm8)
rmse <- RMSE(lm8)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm8)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm8",df)
```

```{r}
lm9 <- lm(Mean_temperature~.-Precipitation-Wind_speed-Standard_pressure-Max_wind_speed, data = wizmir)
summary(lm9)
rmse <- RMSE(lm9)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm9)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm9",df)
```

```{r}
lm10 <- lm(Mean_temperature~.-Precipitation-Wind_speed-Standard_pressure-Max_wind_speed-Dewpoint, data = wizmir)
summary(lm10)
rmse <- RMSE(lm10)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm10)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm10",df)
```

##### Resultados

La unión de las variables *Max_temperature* y *Min_temperature* nos da un *R cuadrado ajustado* de 0.9915 mientras que las de la unión de todas las variables da como resultado 0.9924. Si se quitan las variables apenas hay diferencias respecto al resultado por lo que para una sencilla interpretación de la salida es mejor utilizar el *lm6* por su simplicidad a la hora de elegir variables.

```{r}
df
```

#### Interacciones

Para realizar las *interacciones* se usarán las cinco variables escogidas anteriormente para el ajuste lineal simple.

```{r}
lm11 <- lm(Mean_temperature~Max_temperature*Min_temperature, data = wizmir)
summary(lm11)
rmse <- RMSE(lm11)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm11)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm11",df)
```

```{r}
lm12 <- lm(Mean_temperature~Max_temperature*Dewpoint, data = wizmir)
summary(lm12)
rmse <- RMSE(lm12)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm12)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm12",df)
```

```{r}
lm13 <- lm(Mean_temperature~Max_temperature*Sea_level_pressure, data = wizmir)
summary(lm13)
rmse <- RMSE(lm13)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm13)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm13",df)
```

```{r}
lm14 <- lm(Mean_temperature~Max_temperature*Standard_pressure, data = wizmir)
summary(lm14)
rmse <- RMSE(lm14)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm14)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm14",df)
```

```{r}
# Min_temperature * Dewpoint
lm15 <- lm(Mean_temperature~Min_temperature*Dewpoint, data = wizmir)
summary(lm15)
rmse <- RMSE(lm15)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm15)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm15",df)
```

```{r}
# Min_temperature * Sea_level_pressure
lm16 <- lm(Mean_temperature~Min_temperature*Sea_level_pressure, data = wizmir)
summary(lm16)
rmse <- RMSE(lm16)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm16)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm16",df)
```

```{r}
# Min_temperature * Standard_pressure
lm17 <- lm(Mean_temperature~Min_temperature*Standard_pressure, data = wizmir)
summary(lm17)
rmse <- RMSE(lm17)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm17)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm17",df)
```

```{r}
# Dewpoint * Sea_level_pressure
lm18 <- lm(Mean_temperature~Dewpoint*Sea_level_pressure, data = wizmir)
summary(lm18)
rmse <- RMSE(lm18)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm18)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm18",df)
```

```{r}
# Dewpoint * Standard_pressure
lm19 <- lm(Mean_temperature~Dewpoint*Standard_pressure, data = wizmir)
summary(lm19)
rmse <- RMSE(lm19)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm19)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm19",df)
```

```{r}
# Sea_level_pressure * Standard_pressure
lm20 <- lm(Mean_temperature~Sea_level_pressure*Standard_pressure, data = wizmir)
summary(lm20)
rmse <- RMSE(lm20)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm20)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm20",df)
```

##### Tabla de resultados

```{r}
df
```

Como se puede observar la mejor aproximación que se tiene al realizar las interacciones es la regresión lineal *lm13*, que interacciona *Max_temperature* con *Sea_level_pressure*. Aún así su valor es inferior a *lm6*, tal como se muestra en la siguiente tabla.

#### Ajustes no lineales, polinómicas

El siguiente paso es probar una aproximación polinómica. Para ello se utilizarán cada una de las variables elegidas para la aproximación lineal simple. Mediante la función *poly* se creará un modelo que siga la siguiente estructura: *Y = b0 + (b1 * x) + (b2 * x^2)*. Se generarán dos modelos para cada variable. En el primero de grado muy alto y el segundo se irá reduciendo el grado hasta que la perdida en el *R2 ajustado* sea considerable.

##### Max_temperature

```{r}
# en la función poly se usa el atributo raw para que nose un polinomio ortogonal.

## Polinómica para Max_temperature

nlm1 <- lm(Mean_temperature~poly(Max_temperature, 19, raw = T), data = wizmir)
summary(nlm1)

# Rebajo el grado a 4
nlm1 <- lm(Mean_temperature~poly(Max_temperature, 4, raw = T), data = wizmir)
summary(nlm1)
rmse <- RMSE(nlm1)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(nlm1)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("nlm1",df)

```

##### Min_temperature

```{r}
## Polinómica para Min_temperature

nlm2 <- lm(Mean_temperature~poly(Min_temperature, 19, raw = T), data = wizmir)
summary(nlm2)

# Rebajo el grado a 4
nlm2 <- lm(Mean_temperature~poly(Min_temperature, 4, raw = T), data = wizmir)
summary(nlm2)
rmse <- RMSE(nlm2)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(nlm2)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("nlm2",df)
```

##### Dewpoint

```{r}
## Polinómica para Dewpoint
nlm3 <- lm(Mean_temperature~poly(Dewpoint, 20, raw = T), data = wizmir)
summary(nlm3)

# Rebajo el grado a 5
nlm3 <- lm(Mean_temperature~poly(Dewpoint, 5, raw = T), data = wizmir)
summary(nlm3)
rmse <- RMSE(nlm3)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(nlm3)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("nlm3",df)
```

##### Sea_level_pressure

El modelo obtenido posee un *R2 ajustado* muy bajo.

```{r}
## Polinómica para Sea_level_pressure
nlm4 <- lm(Mean_temperature~poly(Sea_level_pressure, 15, raw = T), data = wizmir)
summary(nlm4)

## Grado 3
nlm4 <- lm(Mean_temperature~poly(Sea_level_pressure, 3, raw = T), data = wizmir)
summary(nlm4)
rmse <- RMSE(nlm3)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(nlm4)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("nlm4",df)
```

##### Standard_pressure

La aproximación no lineal usada para la variable *Standard_pressure* no es muy buena tal como se muestra en el siguiente código:

```{r}
## Polinómica para Standard_pressure, directamente a grado 4
nlm5 <- lm(Mean_temperature~poly(Standard_pressure, 4, raw = T), data = wizmir)
summary(nlm5)
rmse <- RMSE(nlm5)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(nlm5)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("nlm5",df)
```

##### Polinómica unión entre Max_temperature y Min_temperature

Adicionalmente se prueba con un polinómio que mezcle las dos mejores aproximaciones por separado que son *Max_temperature* y *Min_temperature*.

```{r}
## Polinómica unión entre Max_temperature y Min_temperature

nlm6 <- lm(Mean_temperature~Max_temperature +Min_temperature +I(Max_temperature * Min_temperature) +I(Max_temperature^2) +I(Max_temperature^2 * Min_temperature),data = wizmir)
summary(nlm6)
rmse <- RMSE(nlm6)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(nlm6)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("nlm6",df)
```

##### Resultados

A continuación se muestra una tabla con todos los valores obtenidos de las aproximaciones realizadas. Para una mayor facilidad de lectura se descartan todos aquellos ajustes cuyo *R cuadrado* sea inferior al 99%.

```{r}
dfBest <- df[df$porCientoR2 > 99 & df$porCiento_R > 99,]
```

Para elegir el mejor modelo obtenido hasta el momento se mide el *Error Cuadrático Medio (Root Mean Square Error, RMSE)* que es el promedio especial de las diferencias al cuadrado entre la predicción y el análisis del modelo.

Es una medida de cuán bueno es un modelo. Cuanto menor sea el *RMSE*, tanto mejor para el modelo.

```{r}
# Modelo ordenado de menos a mayor RMSE
dfBest[order(dfBest$RMSE),]
```

El modelo que mejor se ajusta según el *RMSE* es el *lm7*, el cuál es un modelo lineal múltiple con todas las variables. Además ese modelo también tiene el mejor valor de error cuadrático. Los siguientes en la lista: *lm8*, *lm9* y *lm10* son modelos multivariables que desestiman algunas de ellas del modelo *lm7*. los tres últimos de la lista son los modelos de interacción, de no linealidad y lineal múltiple entre los dos mejores ajustes lineales por separado, en este orden.

A pesar de ser el último en la lista, por su simplicidad y por la diferencia de tan solo un 0.06 respecto al mejor de la lista en el *RMSE* el modelo seleccionado hasta el momento como el adecuado es el *lm6*.

### KNN

*K near neighbors, KNN* es un algoritmo simple que almacena todos los casos disponibles y predice un objetivo numérico basado en una medidas similares. *KNN* se utiliza en la estimación estadística y reconocimiento de patrones desde principios de los setenta como una técnica no paramétrica.

A continuación se le aplicará el algoritmo *KNN* a los mejores modelos obtenidos hasta el momento. El algoritmo se desarrollará utilizando la distancia *Euclidea*, el número de vecinos será igual a siete, el *kernel* utilizado será el *optimal* y las variables estarán escaladas para tener igual desviación estandar.

#### Modelo Max_temperature + Min_temperature (lm6)

```{r}
# knn para los mejores modelos hasta el momento
# La función kknn tiene por defecto:
#  k = 7 (número de vecinos), distance = 2 (euclidea), kernel = "optimal“ y scale=TRUE

## Max_temperature + Min_temperature (lm6)
knn1 <- kknn(Mean_temperature~Max_temperature + Min_temperature, wizmir, wizmir)
#rmse <- sqrt(sum((Mean_temperature-yprime)^2)/length(yprime)) #RMSE
rmse <- knnRMSE(knn1)

# Almacenamiento del error RMSE en el data.frame df
df <- rbind(df, c(NA,NA,NA,NA,rmse))
df <- putName("knn1",df)
```

#### Mean_temperature ~ . (lm7)

```{r}
## Mean_temperature ~ . (lm7)
knn2 <- kknn(Mean_temperature ~ ., wizmir, wizmir)
# Error RMSE knn
rmse <- knnRMSE(knn2)

# Almacenamiento del error RMSE en el data.frame df
df <- rbind(df, c(NA,NA,NA,NA,rmse))
df <- putName("knn2",df)
```

#### Mean_temperature ~ . - Precipitation - Wind_speed (lm8)

```{r}
##  Mean_temperature ~ . - Precipitation - Wind_speed (lm8)
knn3 <- kknn( Mean_temperature ~ . - Precipitation - Wind_speed, wizmir, wizmir)
# Error RMSE knn
rmse <- knnRMSE(knn3)
# Almacenamiento del error RMSE en el data.frame df
df <- rbind(df, c(NA,NA,NA,NA,rmse))
df <- putName("knn3",df)
```

#### Mean_temperature ~ . - Precipitation - Wind_speed - Standard_pressure - Max_wind_speed (lm9)

```{r}
## Mean_temperature ~ . - Precipitation - Wind_speed - Standard_pressure - Max_wind_speed (lm9)
knn4 <- kknn(Mean_temperature ~ . - Precipitation - Wind_speed - Standard_pressure - Max_wind_speed, wizmir, wizmir)
# Error RMSE knn
rmse <- knnRMSE(knn4)
# Almacenamiento del error RMSE en el data.frame df
df <- rbind(df, c(NA,NA,NA,NA,rmse))
df <- putName("knn4",df)
```

#### Mean_temperature ~ . - Precipitation - Wind_speed - Standard_pressure - Max_wind_speed - Dewpoint (lm10)

```{r}
## Mean_temperature ~ . - Precipitation - Wind_speed - Standard_pressure -
# Max_wind_speed - Dewpoint (lm10)
knn5 <- kknn(Mean_temperature ~ . - Precipitation - Wind_speed - Standard_pressure - Max_wind_speed - Dewpoint, wizmir, wizmir)
rmse <- knnRMSE(knn5)
# Almacenamiento del error RMSE en el data.frame df
df <- rbind(df, c(NA,NA,NA,NA,rmse))
df <- putName("knn5",df)
```

#### Mean_temperature ~ Max_temperature * Min_temperature (lm11)

```{r}
## Mean_temperature ~ Max_temperature * Min_temperature (lm11)
knn6 <- kknn(Mean_temperature ~ Max_temperature * Min_temperature, wizmir, wizmir)
rmse <- knnRMSE(knn6)
# Almacenamiento del error RMSE en el data.frame df
df <- rbind(df, c(NA,NA,NA,NA,rmse))
df <- putName("knn6",df)
```

#### Mean_temperature ~ Max_temperature + Min_temperature + I(Max_temperature * Min_temperature) + I(Max_temperature^2) + I(Max_temperature^2 * Min_temperature) (nlm6)

```{r}
## Mean_temperature ~ Max_temperature + Min_temperature + I(Max_temperature * Min_temperature) +
# I(Max_temperature^2) + I(Max_temperature^2 * Min_temperature) ()
knn7 <- kknn(Mean_temperature ~ Max_temperature + Min_temperature + I(Max_temperature * Min_temperature) + I(Max_temperature^2) + I(Max_temperature^2 * Min_temperature), wizmir, wizmir)
rmse <- knnRMSE(knn7)
# Almacenamiento del error RMSE en el data.frame df
df <- rbind(df, c(NA,NA,NA,NA,rmse))
df <- putName("knn7",df)
```

#### Resultados

En la tabla siguiente se muestran todos los resultados obtenidos en los modelos implementados

```{r}
# Visualización de df
df
```

Para facilitar la lectura se seleccionan los modelos cuyo *RMSE* sea inferior a 2, además se ordenand de menor a mayor para poder observar a simple vista cual de ellos tiene el menor *RMSE*.

```{r}
# Mejores RMSE
dfBest <- df[df$RMSE < 2,]
# Modelo ordenado de menos a mayor RMSE
dfBest[order(dfBest$RMSE),]
```

### K-fold cross-validation

La *validación cruzada* es una técnica utilizada para evaluar los resultados de un análisis estadístico. Consiste en repetir y calcular la media aritmética obtenida de las medidas de evaluación sobre diferentes particiones. Para el estudio se han seleccionado los dos mejores ajustes lineales y los dos mejores ajustes utilizando el algoritmo *knn*. Además se ha añadido el ajuste lineal *lm6* y el *knn1* por su sencilla interpretación.

```{r}
# Función cogida de las transparencias de clase
## Se han realizado algunos cambios.
nombre <- "./wizmir/wizmir"
run_lm_fold <- function(i, x, tt = "test", z) {
  file <- paste(x, "-5-", i, "tra.dat", sep="")
  x_tra <- read.csv(file, comment.char="@")
  file <- paste(x, "-5-", i, "tst.dat", sep="")
  x_tst <- read.csv(file, comment.char="@")
  In <- length(names(x_tra)) - 1
  names(x_tra)[1:In] <- paste ("X", 1:In, sep="")
  names(x_tra)[In+1] <- "Y"
  names(x_tst)[1:In] <- paste ("X", 1:In, sep="")
  names(x_tst)[In+1] <- "Y"
  if (tt == "train") {
    test <- x_tra
  }
  else {
    test <- x_tst
  }
  if(substr(z, start=1, stop=1) == "k"){
    z <- substr(z, start = 2, stop = nchar(z))
    fitMulti=kknn(z,x_tra,test)
    yprime=fitMulti$fitted.values
  }
  else{
    fitMulti = lm(z,x_tra)
    yprime=predict(fitMulti,test)
  }
  sum(abs(test$Y-yprime)^2)/length(yprime) ##MSE
}
```

Una vez definida la función para calcular el *MSE* mediante *K-fold cross-validation*, el siguiente paso es calcular el error para los modelos seleccionados con anterioridad.

```{r}
# lm6 (Mean_temperature~Max_temperature + Min_temperature)
lmMSEtrain_lm6<-mean(sapply(1:5,run_lm_fold,nombre,"train", "Y~X1 + X2"))
lmMSEtest_lm6<-mean(sapply(1:5,run_lm_fold,nombre,"test", "Y~X1 + X2"))

# knn1 (misma fórmula)
lmMSEtrain_knn1<-mean(sapply(1:5,run_lm_fold,nombre,"train", "kY~X1 + X2"))
lmMSEtest_knn1<-mean(sapply(1:5,run_lm_fold,nombre,"test", "kY~X1 + X2"))

# lm7 (Mean_temperature~.)
lmMSEtrain_lm7<-mean(sapply(1:5,run_lm_fold,nombre,"train", "Y~."))
lmMSEtest_lm7<-mean(sapply(1:5,run_lm_fold,nombre,"test", "Y~."))

# lm8 Mean_temperature ~ . - Precipitation - Wind_speed
lmMSEtrain_lm8<-mean(sapply(1:5,run_lm_fold,nombre,"train", "Y~. - X4 - X8"))
lmMSEtest_lm8<-mean(sapply(1:5,run_lm_fold,nombre,"test", "Y~. - X4 - X8"))

# knn6 (Mean_temperature ~ Max_temperature * Min_temperature)
lmMSEtrain_knn6<-mean(sapply(1:5,run_lm_fold,nombre,"train", "kY~X1 * X2"))
lmMSEtest_knn6<-mean(sapply(1:5,run_lm_fold,nombre,"test", "kY~X1 * X2"))

# knn7 (Mean_temperature ~ Max_temperature + Min_temperature +     I(Max_temperature *
# Min_temperature) + I(Max_temperature^2) +     I(Max_temperature^2 * Min_temperature))
lmMSEtrain_knn7<-mean(sapply(1:5,run_lm_fold,nombre,"train", "kY~X1 + I(X1*X2) + 
                             I(X1^2) + I(X1^2 * X2)"))
lmMSEtest_knn7<-mean(sapply(1:5,run_lm_fold,nombre,"test", "kY~X1 + I(X1*X2) +
                            I(X1^2) + I(X1^2 * X2)"))
```

Se introducen los resultados obtenidos en un *data.frame* para compararlos y seleccionar el modelo adecuado.

```{r}
dfMSE <- data.frame(training_error = numeric(0),
                    test_error = numeric(0))

dfMSE[1,] <- c(lmMSEtrain_lm6, lmMSEtest_lm6)
dfMSE <- putName("lm6", dfMSE)
dfMSE <- rbind(dfMSE, c(lmMSEtrain_knn1, lmMSEtest_knn1))
dfMSE <- putName("knn1", dfMSE)
dfMSE <- rbind(dfMSE, c(lmMSEtrain_lm7, lmMSEtest_lm7))
dfMSE <- putName("lm7", dfMSE)
dfMSE <- rbind(dfMSE, c(lmMSEtrain_lm8, lmMSEtest_lm8))
dfMSE <- putName("lm8", dfMSE)
dfMSE <- rbind(dfMSE, c(lmMSEtrain_knn6, lmMSEtest_knn6))
dfMSE <- putName("knn6", dfMSE)
dfMSE <- rbind(dfMSE, c(lmMSEtrain_knn7, lmMSEtest_knn7))
dfMSE <- putName("knn7", dfMSE)
dfMSE
```

Después de observar la tabla podemos comprobar que los modelos lineales se comportan mejor que los determinados a través del *KNN*. El mejor resultado en *test* corresponde al *lm8* que es un ajuste lineal multivariable con todas las variables menos *Precipitation* y *Wind_speed*. La fórmula se muestra a continuación:

```{r}
lm8$call$formula
```

### Comparativa entre distintos algoritmos

A partir de las tablas disponibles en *csv* con resultados de *LM*, *k-NN* y *M5*, que se pueden descargar en *PRADO*, se cargan los datos para aplicar tests estadísticos:

```{r}
#leemos la tabla con los errores medios de test (código sacado de los apuntes)
resultados <- read.csv("./wizmir/regr_test_alumnos.csv")
tablatst <- cbind(resultados[,2:dim(resultados)[2]])
colnames(tablatst) <- names(resultados)[2:dim(resultados)[2]]
rownames(tablatst) <- resultados[,1]
```

Se sustituye el valor tanto de *regresión lineal* como el de *KNN* en la fila del *wizmir* por los valores obtenidos de la regresión lineal multivariable, *lm7*, y de la aplicación de la misma fórmula al *knn*, en este caso *knn1*.

```{r}
# Regresión linear
tablatst["wizmir", "out_test_lm"] <- dfMSE["lm7","test_error"]
tablatst["wizmir", "out_test_kknn"] <- dfMSE["knn1","test_error"]
```

#### Test de Wilcoxon

Se quiere comparar *LM* y *kNN* por *Wilcoxon*. El objetivo del test es comprobar si puede dictaminarse mediante la mediana si los valores *LM* y *KNN* son o no iguales.

En primer lugar se normaliza el error:

```{r}
# Comparativa por pares de LM y KNN (Wilcoxon’s test) ##lm (other) vs knn (ref)
# + 0.1 porque wilcox R falla para valores == 0 en la tabla
difs <- (tablatst[,1] - tablatst[,2]) / tablatst[,1]
```

Se monta una nueva tabla donde para cada conjunto de datos, si la diferencia es positiva se pone 0 para Other y abs(DIFF) para Ref.Alg., y a la inversa si es negativa

```{r}
wilc_1_2 <- cbind(ifelse(difs<0, abs(difs)+0.1, 0+0.1), ifelse(difs>0, abs(difs)+0.1, 0+0.1))
colnames(wilc_1_2) <- c(colnames(tablatst)[1], colnames(tablatst)[2])
head(wilc_1_2)
```

Y finalmente, se aplica el test de *Wilcoxon*.

```{r}
# Se aplica el test y se interpretan los resultados
LMvsKNNtst <- wilcox.test(wilc_1_2[,1], wilc_1_2[,2], alternative = "two.sided", paired=TRUE)
Rmas <- LMvsKNNtst$statistic
pvalue <- LMvsKNNtst$p.value
LMvsKNNtst <- wilcox.test(wilc_1_2[,2], wilc_1_2[,1], alternative = "two.sided", paired=TRUE)
Rmenos <- LMvsKNNtst$statistic
Rmas
Rmenos
pvalue
```

Vemos que el *p-value* obtenido es mayor que 0.05 por lo tanto se acepta la hipótesis nula, es decir, no existen diferencias significativas entre ambos.

Sólo hay un (1-0.5798416) *100 = 42.02% de confianza en que sean distintos.

#### Friedman

Es una prueba no paramétrica que contrasta más de dos grupos relacionados, partiendo de la hipótesis nula que estos provienen de la misma población.

```{r}
test_friedman <- friedman.test(as.matrix(tablatst))
test_friedman
```

Después de observar los resultados del *test de Friedman* se observa que el *p-value* es menor que 0.05 por lo que se rechaza la hipótesis nula y se acepta la alternativa la cuál dice que existen diferencias significativas entre algunos algoritmos.

#### post-hoc Holm

*Post-hoc* analiza los resultados de los datos experimentales. A menudo se basan en una tasa de error familiar; La probabilidad de al menos un error de Tipo I (falso positivo) en un conjunto de comparaciones.

```{r}
tam <- dim(tablatst)
groups <- rep(1:tam[2], each=tam[1])
pairwise.wilcox.test(as.matrix(tablatst), groups, p.adjust = "holm", paired = TRUE)
```

Existen diferencias significativas a favor de *M5* ("3"" vs "1"" 0.081 y "3"" vs "2"" 0.120, con aprox. 90% de confianza) mientras que los otros dos pueden ser considerados equivalentes.

## Clasificación dataset Wisconsin

### Objetivo

Este conjunto de datos contiene casos de un estudio que se llevó a cabo en la Universidad de Wisconsin, sobre los pacientes que se habían sometido a una cirugía para el cáncer de mama. La tarea es determinar si el tumor detectado es benigno o maligno.

### Análisis de datos

#### Análisis general

Para analizar el conjunto de datos proporcionado. En primer lugar se lee y exporta el fichero con los datos de *wisconsin*.

```{r}
# Abrimos el fichero .dat
wbcd <- read.csv2("./wisconsin/wisconsin.dat", header = F, sep = ",",
                  comment.char = "@", stringsAsFactors = FALSE)
names(wbcd) <- c("ClumpThickness", "CellSize", "CellShape", "MarginalAdhesion", "EpithelialSize",
                 "BareNuclei", "BlandChromatin", "NormalNucleoli", "Mitoses", "Class")
```

Seguidamente, se analiza el *data.frame* y el tipo de variables que contiene:

```{r}
## Características generales de wizmir
attach(wbcd)
is.data.frame(wbcd)
dim(wbcd)
str(wbcd)

### Cambio de tipo de la variable 'BareNuclei' a integer
wbcd$BareNuclei <- as.integer(BareNuclei)

### Existen valores "NA"
table(is.na(wbcd))
colSums(is.na(wbcd))
```

De los 699 casos que posee el *dataset*, 16 de ellos en la variable *BareNuclei* tienen valores *NA*. En un principio se eliminan estas filas quedando el *dataset* con 683 ejemplos.

```{r}
wbcd <- na.omit(wbcd)
nrow(wbcd)
```

Resumen general del *data.frame* en el que se nos muestran valores como: el primer cuartil, la mediana, el tercer cuartil, la media y los *NA's* encontrados de cada variable.

```{r}
summary(wbcd)
```

A continuación, se calculan algunas métricas que no salen en *summary*:

```{r}
## Desviación estandar para cada una de las variables
allSd <- apply(wbcd, 2, sd)
## Mediana de cada una de las variables
allMedian <- apply(wbcd, 2, median)
## Rango intercuartílico
allIQR <- apply(wbcd, 2, IQR)
```

Por último, se grafican todas las variables todas con todas.

```{r, fig.cap="plot de todas las variables de Wisconsin.\\label{fig:plotWbcd}"}
# Gráfica de todos con todos
plot(wbcd,  col=wbcd[,10])
```

### Variables

Conjunto de datos explicado uno a uno.

#### ClumpThickness

Esta variable hace referencia al hecho de que las células benignas tienden a agruparse en monocapas, mientras que las células cancerosas suelen agruparse en multicapas.

#### CellSize

Las células cancerosas tienden a variar en tamaño. Es por eso que estos parámetros son valiosos para determinar si las células son cancerosas o no.

#### CellShape

Es normal que las células cancerosas cambien en forma. Por eso es importante conocer el valor de esta variable.

#### MarginAdhension

Las células normales tienden a permanecer juntas. En cambio, las células cancerosas tienden a perder adhesión. Por lo tanto, la pérdida de adhesión es un signo de que la célula puede ser maligna.

#### EpithelialSize

Esta variable está relacionada con la uniformidad de la célula. Las células epiteliales que se agrupan significativamente pueden ser malignas.

#### BareNuclei

La variable *BareNuclei* hace referencia al término que se utiliza para los núcleos que no están rodeados por el citoplasma. Este suceso es muy típico en tumores benignos.

#### BlandChromatin

Sirve para describir la textura del núcleo visto en las células. En las benignas suele ser uniforme mientras que en las células cancerosas la cromática tiende a ser maligna.

#### NormalNucleoli

Los nucleolos son estructuras pequeñas vistas en el núcleo. Este suele ser muy pequeño en las células normales. En las células cancerosas los nucleolos se hacen más prominentes, y a veces se encuentran más de ellos.

#### Mitoses

Proceso de reproducción de una célula que consiste, fundamentalmente, en la división longitudinal de los cromosomas y en la división del núcleo y del citoplasma. 

#### Class

Tipo de tumor que se tiene: benigno o maligno.

### Clasificación

#### KNN

El algoritmo *knn* es usado como método de clasificación de objetos basado en un entrenamiento mediante ejemplos en el espacio de los elementos. *knn* es un tipo de aprendizaje perezoso, donde la función se aproxima solo localmente y todo el cómputo es diferido a la clasificación.

Para el desarrollo del algoritmo *knn* se va a utilizar *caret*, que es un paquete que proporciona una interfaz a casi 150 algoritmos de aprendizaje automático. También proporciona grandes funciones para muestrear datos, para el entrenamiento y tests, preprocesamiento y la evaluación del modelo entre otras características.

Una vez cargado el paquete *caret*, el siguiente paso es pasar la variable *Class* a factor dándole los valores de *Benign* y *Malignant*.

```{r}
# Desarrollo con caret
require(caret)
# Convertimos la columna de la clase en un factor y le damos los valores de Benigno y Maligno
wbcd$Class <- factor(wbcd$Class, levels = c(2, 4), labels = c("Benign", "Malignant"))

# Vemos la tabla de diagnosis.
table(wbcd$Class)

# Porcentaje de valores Benigno y Maligno
tbOrig <- round(prop.table(table(wbcd$Class)) * 100, digits = 1)
tbOrig
```

Una vez factorizada la variable *Class* y ver el porcentaje de células benignas y células cancerígenas, se dispone a crear el modelo. Para ello se separa el dataset en entrenamiento, el 80%, y test, el 20%, aproximadamente.

```{r}
# Modelando
# 80% train un 20% test
wbcd_train <- wbcd[1:546, ]
wbcd_test <- wbcd[547:683, ]
```

A continuación se ejecuta el modelo. Para ello se pasa se utiliza la función *train* del paquete *caret*. A dicha función se le pasa como parámetros: el objeto que se va a examinar, en este caso el data.frame *wbcd*, *data*, marco de datos a partir del cual se toman preferentemente las variables especificadas en la fórmula. el 

```{r}
# knnFit1
knnFit1 <- train(Class ~ ., data=wbcd_train, method="knn",metric="Accuracy", tuneLength=20,
                 preProc = c("center","scale"))
knnFit1
```

Gráfica donde se muestra los valores de *Accuracy* dependiendo del número de vecinos utilizado.

```{r, fig.cap="plot de knnFit1 \\label{fig:plotKnnFit1}"}
# plot de knnFit1
plot(knnFit1)
```

Posteriormente hallamos la matriz de confusión:

```{r}
# El predict
knnPredict1 <- predict(knnFit1, newdata=wbcd_test)
cmat1 <- confusionMatrix(knnPredict1, wbcd_test$Class, positive="Malignant")
cmat1
```

#### LDA

*Linear Discriminant Analysis* (*LDA*) es una técnica de aprendizaje supervisado para clasificar datos. La idea de *LDA* es obtener una proyección de los datos en un espacio de menor dimensión que los datos entrantes, como proposito de separar las clases lo más posible. Es una técnica de aprendizaje supervisado.

Para utilizar este algorimo también se va a usar el paquete *caret*, quedando el código de la siguiente manera:

```{r}
require(MASS)
trainData <- wbcd[,1:9]
trainClasses <- wbcd[,10]
ldaFit <- train(trainData, trainClasses,
                method = "lda",
                preProcess = c("center", "scale"),
                tuneLength = 10,
                trControl = trainControl(method = "cv"))
cmat2 <- confusionMatrix(ldaFit)
cmat2
```

#### QDA

*Quadratic discriminant analysis* (*QDA*), es un clasificador cuadrático que se utiliza en el aprendizaje automático y la clasificación para separar dos o más clases de objetos por una superficie cuádrica.

Al igual que en el *LDA*, para desarrollar *QDA* se va a utilizar el paquete *caret*:

```{r}
qdaFit <- train(trainData, trainClasses,
                method = "qda",
                preProcess = c("center", "scale"),
                tuneLength = 10,
                trControl = trainControl(method = "cv"))
cmat3 <- confusionMatrix(qdaFit)
cmat3
```

#### Comparativas

Al igual que en el apartado de regresión se va a usar el fichero disponible en *PRADO* para la comparativa de algoritmos.

```{r}
#leemos la tabla con los datos de "Accuracy" (código sacado de los apuntes)
resultados <- read.csv("./wisconsin/clasif_test_alumos.csv")
tablatstClas <- cbind(resultados[,2:dim(resultados)[2]])
colnames(tablatstClas) <- names(resultados)[2:dim(resultados)[2]]
rownames(tablatstClas) <- resultados[,1]
```

Se sustituyen los valores obtenidos experimentalmente por los ya existentes en la tabla para el *dataset* *wisconsin*.

```{r}
tablatstClas["wisconsin", "out_test_knn"] <- 0.9781022
tablatstClas["wisconsin", "out_test_lda"] <- 0.9605
tablatstClas["wisconsin", "out_test_qda"] <- 0.9502
```

Para la comparación de los tres algoritmos se va a utilizar al igual que en regresión el test de Friedman

#### Friedman

```{r}
test_friedman <- friedman.test(as.matrix(tablatstClas))
test_friedman
```

Después de ver los resultados obtenidos al ejecutar el *test de Friedman* se observa que el *p-value* es mayor que 0.05 por lo que se acepta la hipótesis nula la cuál dice que no existen diferencias significativas entre los algoritmos.

\newpage

## Anexos

### Códigos

Para poder ver los códigos al completo dirigirse al siguiente repositorio de *gitHub*:

* [https://github.com/AdCalzadilla/introduccionCienciaDatos](https://github.com/AdCalzadilla/introduccionCienciaDatos)

En los siguientes ficheros se encuentra el código realizado en *r*.

* [Regresión](https://github.com/AdCalzadilla/introduccionCienciaDatos/blob/master/wizRegresion.r)
* [Clasificación](https://github.com/AdCalzadilla/introduccionCienciaDatos/blob/master/wisconsinClas.r)




