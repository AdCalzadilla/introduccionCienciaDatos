---
title: "informe"
author: "Adrián Calzadilla González"
date: "12 de diciembre de 2016"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Regresión data set Wizmir

### Objetivo

Este fichero contiene la información del tiempo de la ciudad de *Esmira* (*Izmir*), que es el segundo mayor puerto de Turquía tras Estambul y la tercera ciudad del país en población con 4.168.415 habitantes en 2015. El fichero posee la información del tiempo correspondiente al periodo *01/01/1994* hasta el *31/12/1997*. A partir de estas características el objetivo es predecir la temperatura media.

### Análisis de datos

#### Hipótesisi inicial

La temperatura media se trata de promedios estadísticos cogidos a lo largo del día, por lo tanto es muy posible que la relación entre la temperatura media y las temperaturas máximas y mínimas sea importante para realizar un buen modelo.

#### Análisis general

Para analizar el conjunto de datos proporcionado. En primer lugar se lee y exporta el fichero con los datos de *wizmir*, se crean las funciones que se van a utilizar en el proceso así como las estructuras de datos necesarias. Se introducen los nombres de las variables a mano y se comprueba si es un *data.frame*.

```{r}
wizmir <- read.csv2("./wizmir/wizmir.dat", header = F, sep = ",", comment.char = "@", dec = ".")
names(wizmir) <- c("Max_temperature", "Min_temperature", "Dewpoint", "Precipitation", "Sea_level_pressure", "Standard_pressure", "Visibility", "Wind_speed", "Max_wind_speed", "Mean_temperature")

# Creamos varias funciones que utilizaremos a lo largo del código

## Función para calcular el porcentaje

percentage <- function(x){
  x * 100
}

## Función para calcular la moda

getMode <- function(v) {
  uniqv <- unique(v)
  uniqv[which.max(tabulate(match(v, uniqv)))]
}

# Función para calcular el error RMSE (Error cuadrático medio)

RMSE <- function(x){
  # Formula
  yprime=predict(x,wizmir)
  sqrt(sum(abs(Mean_temperature-yprime)^2)/length(yprime))
}

# Estructura de datos para guardar los valores obtenidos de un modelo.
df <- data.frame(
  r.squared = numeric(0), 
  porCiento_R = numeric(0), 
  adj.r.squared = numeric(0), 
  porCientoR2 = numeric(0), 
  RMSE = numeric(0))

# Función para crear las filas del data.frame

createRow <- function(x){
  valueList <- c(round(summary(x)$r.squared, digits = 4),
                 percentage(summary(x)$r.squared),
                 round(summary(x)$adj.r.squared, digits = 4),
                 percentage(summary(x)$adj.r.squared),
                 rmse)
}

# Función para poner el nombre a cada fila del data.frame df.

putName <- function(nameRow){
  aux <- row.names(df)
  aux[length(aux)] <- nameRow
  row.names(df) <- aux
  df
}
```

Seguidamente, se analiza el *data.frame* y el tipo de variables que contiene:

```{r}
## Características generales de wizmir
attach(wizmir)
is.data.frame(wizmir)
dim(wizmir)
str(wizmir)

### Existen valores "NA"
table(is.na(wizmir))

### Tipos de datos de las variables
is.double(Max_temperature)
is.double(Min_temperature)
is.double(Dewpoint)
is.double(Precipitation)
is.double(Sea_level_pressure)
is.double(Standard_pressure)
is.double(Visibility)
is.double(Wind_speed)
is.double(Max_wind_speed)
is.double(Mean_temperature)
```

Resumen del *data.frame* en el que se nos muestra el valor máximo y mínimo registrado, el primer cuartil, la mediana, el tercer cuartil y la media de cada variable.

```{r}
summary(wizmir)
```

A continuación, se calculan algunas métricas que no salen en *summary*:

```{r}
## Desviación estandar para cada una de las variables
allSd <- apply(wizmir, 2, sd)
## Mediana de cada una de las variables
allMedian <- apply(wizmir, 2, median)
## Rango intercuartílico
allIQR <- apply(wizmir, 2, IQR)
```

Por último, se grafican todas las variables todas con todas.

```{r}
# Gráfica de todos con todos
plot(wizmir)
```

### Variables

Conjunto de datos explicado uno a uno.

#### Max_temperature

Esta variable se utiliza para guardar la temperatura máxima obtenida en cada observación. Su unidad es el grado *Farenheit*.

#####  Medidas de centralidad

```{r}
mean(Max_temperature)
median(Max_temperature)
getMode(Max_temperature)
```

##### Medidas de dispersión

```{r}
var(Max_temperature)
sd(Max_temperature)
max(Max_temperature)
min(Max_temperature)
range(Max_temperature)
quantile(Max_temperature)
```

##### Gráfica de Max_temperature respecto a Mean_temperature, la salida.

```{r}
plot(Max_temperature, Mean_temperature)
```

#### Min_temperature

Variable que se utiliza para guardar la temperatura mínima registrada a lo largo del día, se mide en grados *Farenheit*.

#####  Medidas de centralidad

```{r}
mean(Min_temperature)
median(Min_temperature)
getMode(Min_temperature)
```

##### Medidas de dispersión

```{r}
var(Min_temperature)
sd(Min_temperature)
max(Min_temperature)
min(Min_temperature)
range(Min_temperature)
quantile(Min_temperature)
```

### Gráfica de Max_temperature respecto a Mean_temperature, la salida.

```{r}
plot(Min_temperature, Mean_temperature)
```

#### Dewpoint

El punto de rocío es la temperatura a la que empieza a condensarse el vapor de agua contenido en el aire. La saturación se produce por un aumento de humedad relativa con la misma temperatura, o por un descenso de temperatura con la misma humedad relativa. En este caso su unidad son los grados *Farenheit*.

#####  Medidas de centralidad

```{r}
mean(Dewpoint)
median(Dewpoint)
getMode(Dewpoint)
```

##### Medidas de dispersión

```{r}
var(Dewpoint)
sd(Dewpoint)
max(Dewpoint)
min(Dewpoint)
range(Dewpoint)
quantile(Dewpoint)
```

##### Gráfica de Dewpoint respecto a Mean_temperature, la salida.

```{r}
plot(Dewpoint, Mean_temperature)
```

#### Precipitation

Se considera *precipitación* a cualquier producto de la condensación del vapor de agua que cae bajo el efecto de la gravedad. Las principales formas de precipitación incluyen: lluvia, aguanieve, nieve y granizo. 

Este fenómeno ocurre cuando una porción de la atmósfera se satura con vapor de agua, de modo que el agua se condensa y cae.

En este caso su unidad son **

##### Medidas de centralidad

```{r}
mean(Precipitation)
median(Precipitation)
getMode(Precipitation)
```

##### Medidas de dispersión

```{r}
var(Precipitation)
sd(Precipitation)
max(Precipitation)
min(Precipitation)
range(Precipitation)
quantile(Precipitation)
```

##### Gráfica de Precipitation respecto a Mean_temperature, la salida.

```{r}
plot(Precipitation, Mean_temperature)
```

#### Sea_level_pressure

La presión atmosférica, a cualquier elevación, se reduce a un valor que se aproxima a la presión al nivel del mar. La unidad en la que se mide esta variable es *inHg*.

##### Medidas de centralidad

```{r}
mean(Sea_level_pressure)
median(Sea_level_pressure)
getMode(Sea_level_pressure)
```

##### Medidas de dispersión

````{r}
var(Sea_level_pressure)
sd(Sea_level_pressure)
max(Sea_level_pressure)
min(Sea_level_pressure)
range(Sea_level_pressure)
quantile(Sea_level_pressure)
```

##### Gráfica de Sea_level_pressure respecto a Mean_temperature, la salida.

```{r}
plot(Sea_level_pressure, Mean_temperature)
```

#### Standard_pressure

#####  Medidas de centralidad

```{r}
mean(Standard_pressure)
median(Standard_pressure)
getMode(Standard_pressure)
```

##### Medidas de dispersión

```{r}
var(Standard_pressure)
sd(Standard_pressure)
max(Standard_pressure)
min(Standard_pressure)
range(Standard_pressure)
quantile(Standard_pressure)
```

##### Gráfica de Standard_pressure respecto a Mean_temperature, la salida.

```{r}
plot(Standard_pressure, Mean_temperature)
```

#### Visibility

##### Medidas de centralidad

```{r}
mean(Visibility)
median(Visibility)
getMode(Visibility)
```

##### Medidas de dispersión

```{r}
var(Visibility)
sd(Visibility)
max(Visibility)
min(Visibility)
range(Visibility)
quantile(Visibility)
```

##### Gráfica de Visibility respecto a Mean_temperature, la salida.

```{r}
plot(Visibility, Mean_temperature)
```

#### Wind_speed

##### Medidas de centralidad

```{r}
mean(Wind_speed)
median(Wind_speed)
getMode(Wind_speed)
```

##### Medidas de dispersión

```{r}
var(Wind_speed)
sd(Wind_speed)
max(Wind_speed)
min(Wind_speed)
range(Wind_speed)
quantile(Wind_speed)
```

##### Gráfica de Wind_speed respecto a Mean_temperature, la salida.

```{r}
plot(Wind_speed, Mean_temperature)
```

#### Max_wind_speed

##### Medidas de centralidad

```{r}
mean(Max_wind_speed)
median(Max_wind_speed)
getMode(Max_wind_speed)
```

##### Medidas de dispersión

```{r}
var(Max_wind_speed)
sd(Max_wind_speed)
max(Max_wind_speed)
min(Max_wind_speed)
range(Max_wind_speed)
quantile(Max_wind_speed)
```

##### Gráfica de Max_wind_speed respecto a Mean_temperature, la salida.

```{r}
plot(Max_wind_speed, Mean_temperature)
```

### Regresión lineal

#### Ajuste lineal simple

Después de graficar cada una de las variables contra la salida, se toman como variables candidatas para el ajuste lineal simple a *Max_temperature* y *Min_temperature* como favoritas. Además también se calcula la regresión lineal a las variables: *Dewpoint*, *Sea_level_pressure* y *Standard_pressure*.

##### Max_temperature

```{r}
lm1 <- lm(Mean_temperature~Max_temperature, data = wizmir)
summary(lm1)
plot(Mean_temperature~Max_temperature, wizmir)
abline(lm1, col="red")
confint(lm1)
rmse <- RMSE(lm1)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm1)
# Almacenamiento de los valores en el data.frame df
df[1,] <- valueList
df <- putName("lm1")
```

##### Min_temperature

```{r}
lm2 <- lm(Mean_temperature~Min_temperature, data = wizmir)
summary(lm2)
plot(Mean_temperature~Min_temperature, wizmir)
abline(lm2, col="red")
confint(lm2)
rmse <- RMSE(lm2)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm2)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm2")
```

##### Dewpoint

```{r}
lm3 <- lm(Mean_temperature~Dewpoint, data = wizmir)
summary(lm3)
plot(Mean_temperature~Dewpoint, wizmir)
abline(lm3, col= "red")
confint(lm3)
rmse <- RMSE(lm3)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm3)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm3")
```

##### Sea_level_pressure

```{r}
lm4 <- lm(Mean_temperature~Sea_level_pressure, data = wizmir)
summary(lm4)
plot(Mean_temperature~Sea_level_pressure, wizmir)
abline(lm4, col = "red")
confint(lm4)
rmse <- RMSE(lm4)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm4)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm4")
```

##### Standard_pressure

```{r}
lm5 <- lm(Mean_temperature~Standard_pressure, data = wizmir)
summary(lm5)
plot(Mean_temperature~Standard_pressure, data = wizmir)
abline(lm5, col = "red")
confint(lm5)
rmse <- RMSE(lm5)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm5)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm5")
```

##### Resultados

Para medir la bondad de los ajustes realizados y ver que ajuste lineal es mejor se va a utlizar el *R cuadrado*.

Al finalizar el ajuste lineal simple de las variables seleccionadas, se ha comprobado que tanto *Max_temperature* como *Min_temperature* tienen un valor de *R cuadrado* muy bueno superior al 91%. Las otras variables quedan descartadas debido a que su *R cuadrado* es muy bajo girando en torno al 61% la mejor de ellas, tal como se muestra en la siguiente tabla:

```{r}
df
```

#### Modelo lineal múltiple

Para ver que ajuste lineal múltiple es mejor se va a utlizar el *R2 ajustado* ya que, *R cuadrado* aumenta automáticamente a medida que se agrega nuevas variables independientes a una ecuación de regresión. *R2 ajustado* aumenta sólo cuando se agregan nuevas variables independientes que hacen aumentar el poder explicativo de la ecuación de regresión.

En primer lugar calculamos el modelo lineal para las dos mejores valores de *R cuadrado* conocidos hasta ahora: *Max_temperature* y *Min_temperature*.

##### Max_temperature y Min_temperature

```{r}
## Max_temperature y Min_temperature (Mejor aproximación por separado)

lm6 <- lm(Mean_temperature~Max_temperature+Min_temperature, data = wizmir)
summary(lm6)
rmse <- RMSE(lm6)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm6)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm6")
```

##### Modelo con todas las variables

```{r}
lm7 <- lm(Mean_temperature~., data = wizmir)
summary(lm7)
rmse <- RMSE(lm7)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm7)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm7")
```

##### Eliminación variables no relevantes

```{r}
lm8 <- lm(Mean_temperature~.-Precipitation-Wind_speed, data = wizmir)
summary(lm8)
rmse <- RMSE(lm8)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm8)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm8")
```

```{r}
lm9 <- lm(Mean_temperature~.-Precipitation-Wind_speed-Standard_pressure-Max_wind_speed, data = wizmir)
summary(lm9)
rmse <- RMSE(lm9)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm9)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm9")
```

```{r}
lm10 <- lm(Mean_temperature~.-Precipitation-Wind_speed-Standard_pressure-Max_wind_speed-Dewpoint, data = wizmir)
summary(lm10)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm10)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm10")
```

##### Resultados

La unión de las variables *Max_temperature* y *Min_temperature* nos da un *R cuadrado ajustado* de 0.9915 mientras que las de la unión de todas las variables da como resultado 0.9924. Si se quitan las variables apenas hay diferencias respecto al resultado por lo que para una sencilla interpretación de la salida es mejor utilizar el *lm6* por su simplicidad a la hora de elegir variables.

```{r}
df
```

#### Interacciones

Para realizar las *interacciones* se usarán las cinco variables escogidas anteriormente para el ajuste lineal simple.

```{r}
lm11 <- lm(Mean_temperature~Max_temperature*Min_temperature, data = wizmir)
summary(lm11)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm11)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm11")
```

```{r}
lm12 <- lm(Mean_temperature~Max_temperature*Dewpoint, data = wizmir)
summary(lm12)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm12)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm12")
```

```{r}
lm13 <- lm(Mean_temperature~Max_temperature*Sea_level_pressure, data = wizmir)
summary(lm13)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm13)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm13")
```

```{r}
lm14 <- lm(Mean_temperature~Max_temperature*Standard_pressure, data = wizmir)
summary(lm14)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm14)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm14")
```

```{r}
# Min_temperature * Dewpoint
lm15 <- lm(Mean_temperature~Min_temperature*Dewpoint, data = wizmir)
summary(lm15)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm15)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm15")
```

```{r}
# Min_temperature * Sea_level_pressure
lm16 <- lm(Mean_temperature~Min_temperature*Sea_level_pressure, data = wizmir)
summary(lm16)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm16)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm16")
```

```{r}
# Min_temperature * Standard_pressure
lm17 <- lm(Mean_temperature~Min_temperature*Standard_pressure, data = wizmir)
summary(lm17)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm17)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm17")
```

```{r}
# Dewpoint * Sea_level_pressure
lm18 <- lm(Mean_temperature~Dewpoint*Sea_level_pressure, data = wizmir)
summary(lm18)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm18)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm18")
```

```{r}
# Dewpoint * Standard_pressure
lm19 <- lm(Mean_temperature~Dewpoint*Standard_pressure, data = wizmir)
summary(lm19)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm19)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm19")
```

```{r}
# Sea_level_pressure * Standard_pressure
lm20 <- lm(Mean_temperature~Sea_level_pressure*Standard_pressure, data = wizmir)
summary(lm20)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(lm20)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("lm20")
```

##### Tabla de resultados

```{r}
df
```

Como se puede observar la mejor aproximación que se tiene al realizar las interacciones es la regresión lineal *lm13*, que interacciona *Max_temperature* con *Sea_level_pressure*. Aún así su valor es inferior a *lm6*, tal como se muestra en la siguiente tabla.

#### Ajustes no lineales, polinómicas

El siguiente paso es probar una aproximación polinómica. Para ello se utilizarán cada una de las variables elegidas para la aproximación lineal simple. Mediante la función *poly* se creará un modelo que siga la siguiente estructura: *Y = b0 + (b1 * x) + (b2 * x^2)*. Se generarán dos modelos para cada variable. En el primero de grado muy alto y el segundo se irá reduciendo el grado hasta que la perdida en el *R2 ajustado* sea considerable.

##### Max_temperature

```{r}
# en la función poly se usa el atributo raw para que nose un polinomio ortogonal.

## Polinómica para Max_temperature

nlm1 <- lm(Mean_temperature~poly(Max_temperature, 19, raw = T), data = wizmir)
summary(nlm1)

# Rebajo el grado a 4
nlm1 <- lm(Mean_temperature~poly(Max_temperature, 4, raw = T), data = wizmir)
summary(nlm1)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(nlm1)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("nlm1")

```

##### Min_temperature

```{r}
## Polinómica para Min_temperature

nlm2 <- lm(Mean_temperature~poly(Min_temperature, 19, raw = T), data = wizmir)
summary(nlm2)

# Rebajo el grado a 4
nlm2 <- lm(Mean_temperature~poly(Min_temperature, 4, raw = T), data = wizmir)
summary(nlm2)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(nlm2)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("nlm2")
```

##### Dewpoint

```{r}
## Polinómica para Dewpoint
nlm3 <- lm(Mean_temperature~poly(Dewpoint, 20, raw = T), data = wizmir)
summary(nlm3)

# Rebajo el grado a 5
nlm3 <- lm(Mean_temperature~poly(Dewpoint, 5, raw = T), data = wizmir)
summary(nlm3)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(nlm3)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("nlm3")
```

##### Sea_level_pressure

El modelo obtenido posee un *R2 ajustado* muy bajo.

```{r}
## Polinómica para Sea_level_pressure, directamente a grado 5
nlm4 <- lm(Mean_temperature~poly(Sea_level_pressure, 15, raw = T), data = wizmir)
summary(nlm4)

nlm4 <- lm(Mean_temperature~poly(Sea_level_pressure, 3, raw = T), data = wizmir)
summary(nlm4)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(nlm4)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("nlm4")
```

##### Standard_pressure

La aproximación no lineal usada para la variable *Standard_pressure* no es muy buena tal como se muestra en el siguiente código:

```{r}
## Polinómica para Standard_pressure, directamente a grado 4
nlm5 <- lm(Mean_temperature~poly(Standard_pressure, 4, raw = T), data = wizmir)
summary(nlm5)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(nlm5)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("nlm5")
```

##### Polinómica unión entre Max_temperature y Min_temperature

Adicionalmente se prueba con un polinómio que mezcle las dos mejores aproximaciones por separado que son *Max_temperature* y *Min_temperature*.

```{r}
## Polinómica unión entre Max_temperature y Min_temperature

nlm6 <- lm(Mean_temperature~Max_temperature +Min_temperature +I(Max_temperature * Min_temperature) +I(Max_temperature^2) +I(Max_temperature^2 * Min_temperature),data = wizmir)
summary(nlm6)

# Lista para ir introduciendo los resultados del r2.
valueList <- createRow(nlm6)

# Almacenamiento de los valores en el data.frame df
df <- rbind(df, valueList)
df <- putName("nlm6")
```

##### Resultados

A continuación se muestra una tabla con todos los valores obtenidos de las aproximaciones realizadas. Para una mayor facilidad de lectura se descartan todos aquellos ajustes cuyo *R cuadrado* sea inferior al 99%.

```{r}
dfBest <- df[df$porCientoR2 > 99 & df$porCiento_R > 99,]
```

Para elegir el mejor modelo obtenido hasta el momento se mide el *Error Cuadrático Medio (Root Mean Square Error, RMSE)* que es el promedio especial de las diferencias al cuadrado entre la predicción y el análisis del modelo.

Es una medida de cuán bueno es un modelo. Cuanto menor sea el *RMSE*, tanto mejor para el modelo.

```{r}
# Modelo ordenado de menos a mayor RMSE
dfBest[order(dfBest$RMSE),]
```

El modelo que mejor se ajusta según el *RMSE* es el *lm7*, el cuál es un modelo lineal múltiple con todas las variables. Los siguientes en la lista: *lm8*, *lm9* y *lm10* son modelos multivariables que desestiman algunas variables del modelo *lm7*. los tres últimos de la lista son los modelos de interacción, de no linealidad y lineal múltiple entre los dos mejores ajustes lineales por separado, en este orden.

A pesar de ser el último en la lista, por su simplicidad y por la diferencia de tan solo un 0.06 respecto al mejor de la lista el modelo seleccionado como el adecuado es el *lm6*.
